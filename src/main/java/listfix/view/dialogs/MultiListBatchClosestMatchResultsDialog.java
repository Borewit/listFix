package listfix.view.dialogs;

import listfix.io.IPlaylistOptions;
import listfix.model.BatchRepair;
import listfix.model.BatchRepairItem;
import listfix.model.playlists.Playlist;
import listfix.view.controls.ClosestMatchesSearchScrollableResultsPanel;
import listfix.view.controls.JTransparentTextArea;
import listfix.view.controls.PlaylistsList;
import listfix.view.support.DualProgressWorker;
import listfix.view.support.IPlaylistModifiedListener;
import listfix.view.support.ProgressWorker;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ItemEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.util.List;
import java.util.concurrent.ExecutionException;

/**
 * This is the results dialog we display when running a batch closest matches search on all entries in multiple playlists.
 */
public class MultiListBatchClosestMatchResultsDialog extends javax.swing.JDialog
{
  private final BatchRepair _batch;
  private boolean _userCancelled = false;
  private static final Logger _logger = LogManager.getLogger(MultiListBatchClosestMatchResultsDialog.class);

  private javax.swing.JButton _btnBrowse;
  private javax.swing.JButton _btnSave;
  private javax.swing.JCheckBox _chkBackup;
  private listfix.view.controls.PlaylistsList _pnlList;
  private listfix.view.controls.ClosestMatchesSearchScrollableResultsPanel _pnlResults;
  private JTextField _txtBackup;
  private final IPlaylistOptions filePathOptions;

  public MultiListBatchClosestMatchResultsDialog(Frame parent, boolean modal, BatchRepair br, IPlaylistOptions filePathOptions)
  {
    super(parent, br.getDescription(), modal);
    this.filePathOptions = filePathOptions;
    _batch = br;
    initComponents();

    getRootPane().setDefaultButton(_btnSave);
    _txtBackup.setText(_batch.getDefaultBackupName());

    // load and repair lists
    final DualProgressDialog<Void, DualProgressWorker.ProgressItem<String>> pd = new DualProgressDialog<>(parent, "Finding Closest Matches...", "Please wait...", "Overall Progress:");
    DualProgressWorker<Void, String> dpw = new DualProgressWorker<>()
    {
      @Override
      protected void process(List<ProgressItem<String>> chunks)
      {
        ProgressItem<String> titem = new ProgressItem<>(true, -1, null);
        ProgressItem<String> oitem = new ProgressItem<>(false, -1, null);
        getEffectiveItems(chunks, titem, oitem);

        if (titem.percentComplete >= 0)
        {
          pd.getTaskProgressBar().setValue(titem.percentComplete);
        }
        if (titem.state != null)
        {
          pd.getTaskLabel().setText(titem.state);
        }
        if (oitem.percentComplete >= 0)
        {
          pd.getOverallProgressBar().setValue(oitem.percentComplete);
        }
        if (oitem.state != null)
        {
          pd.getOverallLabel().setText(oitem.state);
        }
      }

      @Override
      protected Void doInBackground()
      {
        _batch.performClosestMatchRepair(this, filePathOptions);
        return null;
      }
    };
    pd.show(dpw);

    if (!dpw.getCancelled())
    {
      ListSelectionModel lsm = _pnlList.getSelectionModel();
      lsm.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
      lsm.addListSelectionListener(e -> {
        if (e.getValueIsAdjusting())
        {
          return;
        }
        updateSelectedPlaylist();
      });

      _pnlList.initPlaylistsList();

      for (BatchRepairItem item : _batch.getItems())
      {
        IPlaylistModifiedListener listener = this::onPlaylistModified;
        item.getPlaylist().addModifiedListener(listener);
      }

      String listCountTxt;
      if (_batch.getItems().size() == 1)
      {
        listCountTxt = "1 playlist";
      }
      else
      {
        listCountTxt = String.format("%d playlists", _batch.getItems().size());
      }
      _pnlList.setText(listCountTxt);
    }
    else
    {
      _userCancelled = true;
    }
  }

  private void onPlaylistModified(Playlist list)
  {
    _pnlList.playlistModified(list);
  }

  private void updateSelectedPlaylist()
  {
    // Keep the table anchored left...
    _pnlList.anchorLeft();
    int selIx = _pnlList.getSelectedModelRow();
    if (selIx >= 0)
    {
      BatchRepairItem item = _batch.getItem(selIx);
      _pnlResults.setResults(item.getClosestMatches());
    }
  }

  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents()
  {

    JSplitPane jSplitPane1 = new JSplitPane();
    _pnlResults = new ClosestMatchesSearchScrollableResultsPanel();
    _pnlList = new PlaylistsList(_batch);
    JPanel _pnlBackup = new JPanel();
    JPanel _pnlRight = new JPanel();
    _btnSave = new javax.swing.JButton();
    JButton _btnCancel = new JButton();
    JPanel _pnlLeft = new JPanel();
    _chkBackup = new javax.swing.JCheckBox();
    _txtBackup = new JTextField();
    _btnBrowse = new javax.swing.JButton();

    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    addWindowListener(new WindowAdapter()
    {
      public void windowClosing(WindowEvent evt)
      {
        formWindowClosing(evt);
      }
    });

    jSplitPane1.setDividerLocation(150);
    jSplitPane1.setRightComponent(_pnlResults);
    jSplitPane1.setLeftComponent(_pnlList);

    getContentPane().add(jSplitPane1, BorderLayout.CENTER);

    _pnlBackup.setLayout(new BorderLayout());

    _btnSave.setText("Save All Repairs");
    _btnSave.addActionListener(this::_btnSaveActionPerformed);
    _pnlRight.add(_btnSave);

    _btnCancel.setText("Cancel");
    _btnCancel.addActionListener(this::_btnCancelActionPerformed);
    _pnlRight.add(_btnCancel);

    _pnlBackup.add(_pnlRight, BorderLayout.EAST);

    _chkBackup.setText("Backup original files to zip file:");
    _chkBackup.addItemListener(this::_chkBackuponChkBackupItemStateChanged);
    _pnlLeft.add(_chkBackup);

    _txtBackup.setEnabled(false);
    _txtBackup.setPreferredSize(new Dimension(200, 20));
    _pnlLeft.add(_txtBackup);

    _btnBrowse.setText("...");
    _btnBrowse.setEnabled(false);
    _btnBrowse.addActionListener(this::_btnBrowseActionPerformed);
    _pnlLeft.add(_btnBrowse);

    _pnlBackup.add(_pnlLeft, BorderLayout.WEST);

    getContentPane().add(_pnlBackup, BorderLayout.SOUTH);

    pack();
  }

  private void formWindowClosing(WindowEvent ignore)
  {
    _userCancelled = true;
  }

  private void _btnSaveActionPerformed(ActionEvent ignore)
  {
    if (_pnlResults.getSelectedRow() > -1 && _pnlResults.getSelectedColumn() == 3)
    {
      TableCellEditor cellEditor = _pnlResults.getCellEditor(_pnlResults.getSelectedRow(), _pnlResults.getSelectedColumn());
      cellEditor.stopCellEditing();
    }

    ProgressWorker<Void, String> worker = new ProgressWorker<>()
    {
      @Override
      protected Void doInBackground() throws Exception
      {
        _batch.save(filePathOptions, true, _chkBackup.isSelected(), _txtBackup.getText(), this);
        return null;
      }
    };
    ProgressDialog pd = new ProgressDialog(null, true, worker, "Saving playlists...");
    pd.setVisible(true);

    try
    {
      worker.get();
    }
    catch (InterruptedException ex)
    {
      // ignore, these happen when people cancel - should not be logged either.
    }
    catch (ExecutionException eex)
    {
      Throwable ex = eex.getCause();
      String msg = "An error occurred while saving: " + ex.getMessage();
      JOptionPane.showMessageDialog(MultiListBatchClosestMatchResultsDialog.this, new JTransparentTextArea(msg), "Save Error", JOptionPane.ERROR_MESSAGE);
      _logger.error(ex);
      return;
    }

    setVisible(false);
  }

  private void _btnCancelActionPerformed(ActionEvent ignore)
  {
    _userCancelled = true;
    setVisible(false);
  }

  private void _chkBackuponChkBackupItemStateChanged(ItemEvent ignore)
  {
    boolean isChecked = _chkBackup.isSelected();
    _txtBackup.setEnabled(isChecked);
    _btnBrowse.setEnabled(isChecked);
    if (isChecked)
    {
      _txtBackup.selectAll();
      _txtBackup.requestFocusInWindow();
    }
  }

  private void _btnBrowseActionPerformed(ActionEvent ignore)
  {
    JFileChooser dlg = new JFileChooser();
    if (!_txtBackup.getText().isEmpty())
    {
      dlg.setSelectedFile(new File(_txtBackup.getText()));
    }
    if (dlg.showSaveDialog(this) == JFileChooser.APPROVE_OPTION)
    {
      _txtBackup.setText(dlg.getSelectedFile().getAbsolutePath());
    }
  }

  public boolean getUserCancelled()
  {
    return _userCancelled;
  }
}
